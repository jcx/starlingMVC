{"note":"Don't delete this file! It's used internally to help with page regeneration.","name":"StarlingMVC","tagline":"IOC Framework for Starling based games","body":"StarlingMVC Framework\r\n===========\r\n\r\nStarlingMVC is an IOC framework for use in games built using the great [Starling framework](http://gamua.com/starling/). Closely modelled after established IOC frameworks like [Swiz](http://swizframework.org/) and [RobotLegs](http://www.robotlegs.org/), StarlingMVC features:\r\n* Dependency Injection(DI)/Inversion of Control(IOC)\r\n* View Mediation\r\n* Event Handling\r\n* Stays out of the way of your Starling game code\r\n* Simple configuration\r\n* Easily extended\r\n* More utilities to help with your game code\r\n\r\nStarlingMVC Framework is provided under the [Apache License 2.0](http://www.apache.org/licenses/LICENSE-2.0).\r\n\r\nRequirements\r\n------------\r\n* [Flex SDK 4.6](http://www.adobe.com/devnet/flex/flex-sdk-download.html)\r\n* [Starling 1.1](http://gamua.com/starling/)\r\n* [FlexUnit 4.1 (For running the unit tests)](http://www.flexunit.org/)\r\n\r\nContributors\r\n------------\r\n* [Creative Bottle, Inc](http://www.creativebottle.com)\r\n* [Scott Jeppesen](mailto:scott.jeppesen@creativebottle.com)\r\n* [Tom McAvoy](mailto:tom.mcavoy@creativebottle.com)\r\n\r\nSetup\r\n------------\r\nGetting your Starling project configured to work with StarlingMVC requires only a few lines of code. From your base Starling display class (starling.display.*), you need to create an instance of StarlingMVC and provide it the root Starling display object, an instance of StarlingMVCConfig, and some Beans.\r\n\r\n```as3\r\npackage com.mygame.views\r\n{\r\n  \timport com.creativebottle.starlingmvc.StarlingMVC;\r\n\timport com.creativebottle.starlingmvc.config.StarlingMVCConfig;\r\n\timport com.creativebottle.starlingmvc.views.ViewManager;\r\n \timport com.mygame.models.GameModel;\r\n\r\n\timport starling.core.Starling;\r\n\timport starling.display.Sprite;\r\n\r\n\tpublic class GameMain extends Sprite\r\n\t{\r\n\t\tprivate var starlingMVC:StarlingMVC;\r\n\r\n\t\tpublic function GameMain()\r\n\t\t{\r\n\t\t\tvar config:StarlingMVCConfig = new StarlingMVCConfig();\r\n\t\t\tconfig.eventPackages = [\"com.mygame.events\"];\r\n\t\t\tconfig.viewPackages = [\"com.mygame.views\"];\r\n\r\n\t\t\tvar beans:Array = [new GameModel(), new ViewManager(this)];\r\n\r\n\t\t\tstarlingMVC = new StarlingMVC(this, config, beans);\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\nThe StarlingMVCConfig instance above tells StarlingMVC which event packages and view packages it should mediate.\r\nThe beans Array is merely a collection of objects. The array can accept an object of any type. The framework will handle it accordingly.\r\n\r\nBeans\r\n------------\r\nA Bean is an instance of an object that is provided to StarlingMVC to manage. Beans can be injected, receive injections, and handle events. There are several ways that beans can be provided to StarlingMVC during setup:\r\n###Object instance\r\n```as3\r\nvar beans:Array = [new GameModel(), new ViewManager(this)];\r\n```\r\n\r\n\r\n###Bean instances\r\n```as3\r\nvar beans:Array = [new Bean(new GameModel()), new Bean(new ViewManager(this))];\r\n```\r\nProviding a Bean instance as shown above does not give much benefit. However, there is an option second parameter to thw Bean constructor that allows for an id. If you provide an id then you can use the id during dependency injection. Additionally, beans are stored within the framework by class type unless you provide an id. So if you have two beans of the same type you will need to specify an id or subsequent beans will overwrite the previous beans. For example:\r\n```as3\r\nvar beans:Array = [new Bean(new GameModel(),\"gameModelEasy\"),new Bean(new GameModel(),\"gameModelHard\"), new ViewManager(this)];\r\n```\r\n\r\n###BeanProvider instances\r\nA BeanProvider is a collection of Beans. The beans within the provider, like with a simple array, can be of any type, including BeanProvider.\r\n```as3\r\npackage com.mygame.config\r\n{\r\n\timport com.creativebottle.starlingmvc.beans.BeanProvider;\r\n\timport com.mygame.assets.AssetModel;\r\n\timport com.mygame.models.AudioModel;\r\n\timport com.mygame.models.GameModel;\r\n\r\n\tpublic class Models extends BeanProvider\r\n\t{\r\n\t\tpublic function Models()\r\n\t\t{\r\n\t\t\tbeans = [new GameModel(), new Bean(new AudioModel(),\"audioModel\"), new AssetModel()];\r\n\t\t}\r\n\t}\r\n}\r\n```\r\nOnce you have your BeanProvider set up, you can pass that as a part of your original beans array.\r\n```as3\r\nvar beans:Array = [new Models(), new ViewManager(this)];\r\n```\r\n\r\n###ProtoBeans\r\nA ProtoBean is a bean that is created at the time of injection. Where normal beans require a class instance, a ProtoBean requires a class and an id.\r\n```as3\r\nvar beans:Array = [new ProtoBean(Character,\"character\"), new ViewManager(this)];\r\n```\r\nUsing a ProtoBean here will allow StarlingMVC to create the instances of this class for you. Each time it is injected, it will be a new instance of the, in this case, \"Character\" class instead of using a singleton like a normal Bean. The advantage to allowing the framework to create the class over just using \"new Character()\" is that when StarlingMVC creates the instance it will run injection and all processing on the created instance.\r\n\r\nDependency Injection\r\n------------\r\nDependency injection occurs on all beans and all Starling display objects. A dependency is denoted with an `Inject` metadata tag over a public property or getter/setter. Injection can be done by type:\r\n```as3\r\npackage com.mygame.controllers\r\n{\r\n\tpublic class GameController\r\n\t{\r\n\t\t[Inject]\r\n\t\tpublic var gameModel:GameModel;\r\n\r\n\t\tpublic function GameModel():void\r\n\t\t{\r\n\r\n\t\t}\r\n\t}\r\n}\r\n```\r\nor by id, if an id was specified when the bean was created:\r\n```as3\r\npackage com.mygame.controllers\r\n{\r\n\tpublic class GameController\r\n\t{\r\n\t\t[Inject(source=\"gameModel\")]\r\n\t\tpublic var gameModel:GameModel;\r\n\r\n\t\tpublic function GameModel():void\r\n\t\t{\r\n\r\n\t\t}\r\n\t}\r\n}\r\n```\r\nIn the above example, if the GameModel is a normal bean, the framework will set the value to the singleton instance that was created during setup. If it was a protobean, a new instance will be created and injected into the property.\r\n\r\nStarling also supports injecting properties of beans. In order to use this functionality, the source Bean must contain an id (i.e. `new Bean(new GameModel(),\"gameModel\");`). To inject a property of a bean, simply append the property name to the end of the id parameter in your Inject tag:\r\n```as3\r\npackage com.mygame.controllers\r\n{\r\n\tpublic class GameController\r\n\t{\r\n\t\t[Inject(source=\"gameModel\")]\r\n\t\tpublic var gameModel:GameModel;\r\n\r\n\t\t[Inject(source=\"userModel.currentUser\")]\r\n\t\tpublic var currentUser:User;\r\n\r\n\t\tpublic function GameModel():void\r\n\t\t{\r\n\r\n\t\t}\r\n\t}\r\n}\r\n```\r\nIn the example above, the value of the `currentUser` property on the `userModel` bean would be injected into the currentUser property of our controller. This functionality is also recursive. If you wanted to inject the first name of the currentUser you could potentially use `[Inject(source=\"userModel.currentUser.firstName\")]`.\r\n\r\n###Binding\r\nThe InjectProcessor also supports a very simple binding mechanism that will cause injected properties to be automatically refreshed when they are changed.\r\n```as3\r\npackage com.mygame.controllers\r\n{\r\n\tpublic class GameController\r\n\t{\r\n\t\t[Inject(source=\"gameModel\")]\r\n\t\tpublic var gameModel:GameModel;\r\n\r\n\t\t[Inject(source=\"userModel.currentUser\", bind=\"true\")]\r\n\t\tpublic var currentUser:User;\r\n\r\n\t\tpublic function GameModel():void\r\n\t\t{\r\n\r\n\t\t}\r\n\t}\r\n}\r\n```\r\nThe example above uses the optional `bind=\"true\"` parameter of the `[Inject]` tag to create a binding.  When the currentUser property of the userModel is updated StarlingMVC will automatically update any injections using binding. This will also work with getter/setters methods. Using these will allow code to easily react to changes in the properties.\r\n```as3\r\npackage com.mygame.controllers\r\n{\r\n\tpublic class GameController\r\n\t{\r\n\t\t[Inject(source=\"gameModel\")]\r\n\t\tpublic var gameModel:GameModel;\r\n\r\n\t\t[Inject(source=\"userModel.currentUser\", bind=\"true\")]\r\n\t\tpublic function set currentUser(value:User):void\r\n\t\t{\r\n\t\t\t_currentUser = value;\r\n\r\n\t\t\t// Do something to update your UI with the new value\r\n\t\t}\r\n\r\n\t\tpublic function get currentUser():User\r\n\t\t{\r\n\t\t\treturn _currentUser;\r\n\t\t}\r\n\t\tprivate var _currentUser:User;\r\n\r\n\t\tpublic function GameModel():void\r\n\t\t{\r\n\r\n\t\t}\r\n\t}\r\n}\r\n```\r\nBinding is connected directly to the Starling juggler instance and will check for changes on each bound property everytime the `advanceTime()` method is called. This does not provide a binding that works as instantaneously as Flex binding, but should offer binding with a lower cost to performance. However, binding should be used sparingly as there is still overhead to check for changes to the bound properties.\r\n\r\nEvents\r\n------------\r\n###Dispatching Events\r\nEvents in StarlingMVC are dispatched in one of two ways:\r\n1) StarlingMVC contains a global instance of `starling.events.EventDispatcher`. The quickest way to dispatch an event into the StarlingMVC framework is to use this dispatcher. This dispatcher can be injected into your bean by using the `[Dispatcher]` metadata tag.\r\n2) DisplayObjects can dispatchEvents using their own `dispatchEvent()` method. This is only available to DisplayObjects and the events must set `bubbles=true'.\r\n\r\n###Handling Events\r\nEvent handlers are denoted by using the `[EventHandler(event=\"\")]` metadata tag on a public method of a bean. The event argument in the tag can contain one of two options: the event type string\r\n```as3\r\npackage com.mygame.controllers\r\n{\r\n\tpublic class GameController\r\n\t{\r\n\t\t[EventHandler(event=\"scoreChanged\")]\r\n\t\tpublic function scoreChanged(event:ScoreEvent):void\r\n\t\t{\r\n\r\n\t\t}\r\n\t}\r\n}\r\n```\r\nor the typed event\r\n```as3\r\npackage com.mygame.controllers\r\n{\r\n\tpublic class GameController\r\n\t{\r\n\t\t[EventHandler(event=\"com.mygame.events.ScoreEvent.SCORE_CHANGED\")]\r\n\t\tpublic function scoreChanged(event:ScoreEvent):void\r\n\t\t{\r\n\r\n\t\t}\r\n\t}\r\n}\r\n```\r\nBy using the second approach, you will gain the benefit that StarlingMVC will type check any of the events during initialization and throw and error if the event or event type doesn't exist. This protects against typos.\r\n\r\nIn both examples above, the handler must accept the type of the dispatched event to handle. However, a second optional parameter exists in the EventHandler tag that will allow you to specify specific properties of the event to use as parameters to the event handler. For example:\r\n```as3\r\npackage com.mygame.controllers\r\n{\r\n\tpublic class GameController\r\n\t{\r\n\t\t[EventHandler(event=\"com.mygame.events.ScoreEvent.SCORE_CHANGED\", properties=\"user, newScore\")]\r\n\t\tpublic function scoreChanged(user:User, newScore:int):void\r\n\t\t{\r\n\r\n\t\t}\r\n\t}\r\n}\r\n```\r\nIn the above example, instead of passing the entire event into the handler, StarlingMVC will pass only the \"user\" and \"newScore\" properties. Note that the types must match or an error will be thrown.\r\n\r\nView Mediation\r\n------------\r\nView mediators are a great way of keeping your view classes separate from the code that controls them. A view mediator is set up just like any other bean. To link a view to a view mediator a `[ViewAdded]` metadata tag is used on a public method. When a DisplayObject is added to the stack, StarlingMVC will look for instances of the ViewAdded tag. If the parameter of any ViewAdded methods are of the type of the view that was just added, the new DisplayObject will be passed to that method. To unlink a mediator from a view when the view has been removed the `[ViewRemoved]` metadata tag is used.\r\n```as3\r\npackage com.mygame.mediators\r\n{\r\n\tpublic class GameMediator\r\n\t{\r\n\t\tprivate var view:Game;\r\n\r\n\t\t[ViewAdded]\r\n\t\tpublic function viewAdded(view:Game):void\r\n\t\t{\r\n\t\t\tthis.view = view;\r\n\t\t}\r\n\r\n\t\t[ViewRemoved]\r\n\t\tpublic function viewRemoved(view:Game):void\r\n\t\t{\r\n\t\t\tthis.view = null;\r\n\t\t}\r\n\t}\r\n}\r\n```\r\nBean Lifecycle\r\n------------\r\nNormal beans are set up on initialization. However, since the dependency injection and event handling happens after creation bean values are not available immediately. To receive notification of when a bean has been fully processed we can add the `[PostConstruct]` tag to a public method. This method will be automatically called when all DI has been completed. Similarly, when a bean is being destroyed we can specify a public method to be called with the `[PreDestroy]` tag. This works in all standard beans and DisplayObjects.\r\n```as3\r\npackage com.mygame.controllers\r\n{\r\n\tpublic class GameController\r\n\t{\r\n\t\t[Inject]\r\n\t\tpublic var gameModel:GameModel;\r\n\r\n\t\t[PostConstruct]\r\n\t\tpublic function postConstruct():void\r\n\t\t{\r\n\t\t\t// set up code here\r\n\t\t}\r\n\r\n\t\t[PreDestroy]\r\n\t\tpublic function preDestroy():void\r\n\t\t{\r\n\t\t\t// tear down code here\r\n\t\t}\r\n\r\n\t\t[EventHandler(event=\"com.mygame.events.ScoreEvent.SCORE_CHANGED\", properties=\"user, newScore\")]\r\n\t\tpublic function scoreChanged(user:User, newScore:int):void\r\n\t\t{\r\n\r\n\t\t}\r\n\t}\r\n}\r\n```\r\nManual Bean Creation/Removal\r\n------------\r\nManual bean creation and removal is done through the event system. Dispatching `BeanEvent.ADD_BEAN` will add and process a new bean. Dispatching `BeanEvent.REMOVE_BEAN` will remove the bean from the system.\r\n```as3\r\npackage com.mygame.view\r\n{\r\n\tpublic class Game\r\n\t{\r\n\t\tpublic var gamePresentationModel:GamePresentationModel;\r\n\r\n\t\t[PostConstruct]\r\n\t\tpublic function postConstruct():void\r\n\t\t{\r\n\t\t\tgamePresentationModel = new GamePresentationModel();\r\n\r\n\t\t\tdispatchEvent(new BeanEvent(BeanEvent.ADD_BEAN, gamePresentationModel));\r\n\t\t}\r\n\r\n\t\t[PreDestroy]\r\n\t\tpublic function preDestroy():void\r\n\t\t{\r\n\t\t\tdispatchEvent(new BeanEvent(BeanEvent.REMOVE_BEAN, gamePresentationModel));\r\n\r\n\t\t\tgamePresentationModel = null;\r\n\t\t}\r\n\t}\r\n}\r\n```\r\nIn the example above, we create a presentation model for our view and add it to StarlingMVC as a bean. In doing this, the PM will be processed as a bean and gain all of the benefits of DI and EventHandling.\r\n\r\nEventMap\r\n------------\r\nEventMap is a utility class for creating and managing event listeners. Using EventMap exclusively to create listeners within your class makes cleanup very easy.\r\n```as3\r\npackage com.mygame.mediators\r\n{\r\n\timport com.creativebottle.starlingmvc.events.EventMap;\r\n\r\n\tpublic class GameMediator\r\n\t{\r\n\t\tprivate var eventMap:EventMap = new EventMap();\r\n\r\n\t\t[ViewAdded]\r\n\t\tpublic function viewAdded(view:Game):void\r\n\t\t{\r\n\t\t\teventMap.addMap(view.playButton,TouchEvent.TOUCH, playButtonTouched);\r\n\t\t\teventMap.addMap(view.instructionsButton,TouchEvent.TOUCH, instructionsTouched);\r\n\t\t}\r\n\r\n\t\t[ViewRemoved]\r\n\t\tpublic function viewRemoved(view:Game):void\r\n\t\t{\r\n\t\t\tevent.removeAllMappedEvents();\r\n\t\t}\r\n\r\n\t\tprivate function playButtonTouched(event:TouchEvent):void\r\n\t\t{\r\n\r\n\t\t}\r\n\r\n\t\tprivate function instructionsButtonTouched(event:TouchEvent):void\r\n\t\t{\r\n\r\n\t\t}\r\n\t}\r\n}\r\n```\r\nJuggler\r\n------------\r\nThe Juggler class in Starling is used to handle all animation within a game. For a class to take advantage of the Juggler instance, it must implement the IAnimatable interface but defining `advanceTime(time:Number)`. The global juggler reference can be accessed as a static property of Starling as `Starling.juggler1`. However, this property can also be directly injected into your class instances using the `[Juggler]` tag.\r\n ```as3\r\n package com.mygame.mediators\r\n {\r\n \timport com.creativebottle.starlingmvc.events.EventMap;\r\n\r\n \tpublic class GameMediator implements IAnimatable\r\n \t{\r\n \t\t[Juggler]\r\n        public var juggler:Juggler;\r\n\r\n \t\t[ViewAdded]\r\n \t\tpublic function viewAdded(view:Game):void\r\n \t\t{\r\n \t\t\tjuggler.add(this);\r\n \t\t}\r\n\r\n \t\t[ViewRemoved]\r\n \t\tpublic function viewRemoved(view:Game):void\r\n \t\t{\r\n \t\t    juggler.remove(this);\r\n \t\t}\r\n\r\n \t\tpublic function advanceTime(time:Number):void\r\n \t\t{\r\n            // do some animation logic\r\n \t\t}\r\n \t}\r\n }\r\n ```\r\n\r\nViewManager\r\n------------\r\nViewManager is a utility class to facilitate creating views and adding/removing them from the stage. When creating the instance of ViewManager the constructor requires a reference to the root view of the game (i.e. `new ViewManager(this)`) from the root DisplayObject. Adding the ViewManager instance to the StarlingMVC beans makes it easy to swap views from anywhere in the Starling application.\r\n###setView\r\nCalls to setView will remove existing views and add the new view. ViewManager handles instantiating the view and adding it to the stack.\r\n```as3\r\npackage com.mygame.controllers\r\n{\r\n\tpublic class NavigationController\r\n\t{\r\n\t\t[Inject]\r\n\t\tpublic var viewManager:ViewManager;\r\n\r\n\t\t[EventHandler(event=\"com.mygame.events.NavigationEvent.NAVIGATE_TO_VIEW\", properties=\"viewClass\")]\r\n\t\tpublic function navigateToView(viewClass:Class):void\r\n\t\t{\r\n\t\t\tviewManager.setView(viewClass);\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n###addView\r\nCalls to addView will add a new view on top of the existing view. This is handy for popups, HUDs, etc. Whereas setView accepts a parameter of type Class, addView accepts a view instance.\r\n```as3\r\npackage com.mygame.views\r\n{\r\n\tpublic class Game\r\n\t{\r\n\t\t[Inject]\r\n\t\tpublic var viewManager:ViewManager;\r\n\r\n\t\tprivate var hud:GameHUD;\r\n\r\n\t\t[PostConstruct]\r\n\t\tpublic function postConstruct():void\r\n\t\t{\r\n\t\t\thud = new GameHUD();\r\n\r\n\t\t\tviewManager.addView(hud);\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n###removeView\r\nCalls to removeView will remove the specified view from the stack.\r\n###removeAll\r\nCalls to removeAll will remove all views from the stack. This is called automatically when calling `setView()`.\r\n","google":"UA-33037675-1"}